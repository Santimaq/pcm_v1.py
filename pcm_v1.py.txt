cat > gui_pcm5102.py <<'PY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import threading
import queue
import numpy as np
import sounddevice as sd
import soundfile as sf
import time

def pick_hifiberry_device():
    try:
        devices = sd.query_devices()
        for idx, d in enumerate(devices):
            name = str(d.get('name', '')).lower()
            if 'hifiberry' in name or 'snd_rpi_hifiberry' in name or 'i2s' in name:
                return idx
    except Exception:
        pass
    return None

class ToneGenerator(object):
    def __init__(self, samplerate=48000):
        self.fs = samplerate
        self.phase = 0.0
        self.two_pi = 2*np.pi
        self.lock = threading.Lock()
        self._freq = 440.0
        self._vol = 0.2
        self._wave = 'sine'
        self.enabled = False

    def set_params(self, freq=None, vol=None, wave=None, enabled=None):
        with self.lock:
            if freq is not None:  self._freq = max(20.0, min(20000.0, float(freq)))
            if vol is not None:   self._vol = max(0.0, min(1.0, float(vol)))
            if wave is not None:  self._wave = wave
            if enabled is not None: self.enabled = bool(enabled)

    def callback(self, outdata, frames, time_info, status):
        if status:
            pass
        t = np.arange(frames, dtype=np.float32)
        with self.lock:
            freq = self._freq
            vol  = self._vol
            wave = self._wave
            en   = self.enabled

        if en:
            phase_inc = (self.two_pi * freq) / self.fs
            phases = self.phase + phase_inc * t
            if wave == 'square':
                mono = np.sign(np.sin(phases)).astype(np.float32) * vol
            else:
                mono = np.sin(phases).astype(np.float32) * vol
            self.phase = (self.phase + phase_inc * frames) % self.two_pi
        else:
            mono = np.zeros(frames, dtype=np.float32)

        stereo = np.column_stack((mono, mono))
        outdata[:] = stereo

class WAVPlayer(object):
    def __init__(self, samplerate=48000, device=None):
        self.fs = samplerate
        self.device = device
        self.thread = None
        self.stop_flag = threading.Event()   # ← aquí estaba el exceso de indentación
        self.volume = 1.0
        self._play_queue = queue.Queue(maxsize=1)

    def set_volume(self, v):
        self.volume = max(0.0, min(1.0, float(v)))

    def play_file(self, path):
        self.stop()
        try:
            self._play_queue.queue.clear()
        except Exception:
            pass
        self._play_queue.put(path)
        self.stop_flag.clear()
        self.thread = threading.Thread(target=self._run, daemon=True)
        self.thread.start()

    def _run(self):
        try:
            path = self._play_queue.get_nowait()
        except queue.Empty:
            return
        try:
            data, fs = sf.read(path, dtype='float32', always_2d=True)
        except Exception as e:
            messagebox.showerror("Error al abrir", "No se pudo abrir el archivo:\n{}".format(e))
            return

        if fs != self.fs:
            ratio = float(self.fs) / float(fs)
            n_out = int(data.shape[0] * ratio)
            x_old = np.linspace(0.0, 1.0, num=data.shape[0], endpoint=False)
            x_new = np.linspace(0.0, 1.0, num=n_out, endpoint=False)
            left  = np.interp(x_new, x_old, data[:,0])
            if data.shape[1] > 1:
                right = np.interp(x_new, x_old, data[:,1])
            else:
                right = left
            data = np.column_stack((left, right)).astype('float32')

        block = 1024
        try:
            with sd.OutputStream(samplerate=self.fs, channels=2, device=self.device, dtype='float32') as stream:
                i = 0
                n = len(data)
                while i < n and not self.stop_flag.is_set():
                    chunk = data[i:i+block] * self.volume
                    stream.write(chunk)
                    i += block
        except Exception as e:
            messagebox.showerror("Error de audio", "No se pudo reproducir:\n{}".format(e))

    def stop(self):
        if self.thread and self.thread.is_alive():
            self.stop_flag.set()
            self.thread.join(timeout=1.0)
        self.thread = None
        self.stop_flag.clear()

class App(tk.Tk):
    def __init__(self):
        tk.Tk.__init__(self)
        self.title("Control PCM5102 (I2S) - Raspberry Pi")
        self.geometry("560x420")
        self.resizable(False, False)

        device_idx = pick_hifiberry_device()
        self.device_label_text = tk.StringVar()
        if device_idx is None:
            self.device_label_text.set("Dispositivo: predeterminado (no se detectó hifiberry)")
        else:
            self.device_label_text.set("Dispositivo: #{} (hifiberry/I2S)".format(device_idx))

        self.fs = 48000
        self.tone = ToneGenerator(samplerate=self.fs)
        self.player = WAVPlayer(samplerate=self.fs, device=device_idx)

        try:
            self.stream = sd.OutputStream(samplerate=self.fs, channels=2,
                                          callback=self.tone.callback,
                                          device=device_idx, dtype='float32')
            self.stream.start()
        except Exception as e:
            messagebox.showerror("Error de audio", "No se pudo abrir el dispositivo de salida:\n{}".format(e))
            self.stream = None

        self._make_widgets()

    def _make_widgets(self):
        padx = 12; pady = 8
        ttk.Label(self, textvariable=self.device_label_text).pack(anchor='w', padx=padx, pady=pady)

        frame_tone = ttk.LabelFrame(self, text="Generador de Tono")
        frame_tone.pack(fill='x', padx=padx, pady=pady)

        self.freq_var = tk.DoubleVar(value=440.0)
        ttk.Label(frame_tone, text="Frecuencia (Hz)").grid(row=0, column=0, sticky='w', padx=8, pady=6)
        ttk.Scale(frame_tone, from_=20, to=20000, variable=self.freq_var,
                  command=self._on_freq_change).grid(row=0, column=1, sticky='we', padx=8, pady=6)
        frame_tone.columnconfigure(1, weight=1)
        self.freq_entry = ttk.Entry(frame_tone, width=8)
        self.freq_entry.insert(0, "440")
        self.freq_entry.grid(row=0, column=2, padx=8)
        ttk.Button(frame_tone, text="Set", command=self._set_freq_from_entry).grid(row=0, column=3, padx=8)

        self.vol_var = tk.DoubleVar(value=0.2)
        ttk.Label(frame_tone, text="Volumen").grid(row=1, column=0, sticky='w', padx=8, pady=6)
        ttk.Scale(frame_tone, from_=0.0, to=1.0, variable=self.vol_var,
                  command=self._on_vol_change).grid(row=1, column=1, sticky='we', padx=8, pady=6)

        ttk.Label(frame_tone, text="Onda").grid(row=2, column=0, sticky='w', padx=8, pady=6)
        self.wave_var = tk.StringVar(value='sine')
        wave_box = ttk.Combobox(frame_tone, textvariable=self.wave_var,
                                values=['sine', 'square'], state='readonly', width=10)
        wave_box.grid(row=2, column=1, sticky='w', padx=8, pady=6)
        def _on_wave(_evt=None):
            self.tone.set_params(wave=self.wave_var.get())
        wave_box.bind('<<ComboboxSelected>>', _on_wave)

        tone_btns = ttk.Frame(frame_tone)
        tone_btns.grid(row=3, column=0, columnspan=4, sticky='we', padx=8, pady=6)
        ttk.Button(tone_btns, text="▶ Reproducir tono",
                   command=lambda: self.tone.set_params(enabled=True)).pack(side='left', padx=6)
        ttk.Button(tone_btns, text="⏹ Detener tono",
                   command=lambda: self.tone.set_params(enabled=False)).pack(side='left', padx=6)
        self.mute_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(tone_btns, text="Mute", variable=self.mute_var,
                        command=self._toggle_mute).pack(side='left', padx=6)

        frame_wav = ttk.LabelFrame(self, text="Reproductor de Archivo (WAV/FLAC/OGG)")
        frame_wav.pack(fill='x', padx=padx, pady=pady)
        self.wav_path_var = tk.StringVar(value="")
        ttk.Entry(frame_wav, textvariable=self.wav_path_var).grid(row=0, column=0, columnspan=3,
                                                                  sticky='we', padx=8, pady=6)
        frame_wav.columnconfigure(0, weight=1)
        ttk.Button(frame_wav, text="Buscar...", command=self._browse_wav).grid(row=0, column=3, padx=8, pady=6)
        ttk.Button(frame_wav, text="▶ Reproducir", command=self._play_wav).grid(row=1, column=2, padx=8, pady=6, sticky='e')
        ttk.Button(frame_wav, text="⏹ Detener", command=self.player.stop).grid(row=1, column=3, padx=8, pady=6, sticky='w')

        ttk.Label(frame_wav, text="Volumen archivo").grid(row=1, column=0, sticky='w', padx=8)
        self.wav_vol_var = tk.DoubleVar(value=1.0)
        ttk.Scale(frame_wav, from_=0.0, to=1.0, variable=self.wav_vol_var,
                  command=lambda e: self.player.set_volume(self.wav_vol_var.get())).grid(row=1, column=1, sticky='we', padx=8)

        tips = ("Tips:\n"
                "• Si no suena, revisá /boot/config.txt (hifiberry-dac) y el cableado I2S.\n"
                "• Esta app usa 48 kHz.\n"
                "• Cerrá otras apps que usen audio si te dice 'dispositivo ocupado'.")
        ttk.Label(self, text=tips, justify='left').pack(fill='x', padx=12, pady=8)

        ttk.Button(self, text="Salir", command=self.on_close).pack(pady=4)

        self._on_freq_change(None)
        self._on_vol_change(None)
        self.tone.set_params(wave=self.wave_var.get(), enabled=False)

    def _on_freq_change(self, _evt):
        f = float(self.freq_var.get())
        self.tone.set_params(freq=f)

    def _on_vol_change(self, _evt):
        if self.mute_var.get():
            self.tone.set_params(vol=0.0)
        else:
            self.tone.set_params(vol=float(self.vol_var.get()))

    def _toggle_mute(self):
        self._on_vol_change(None)

    def _set_freq_from_entry(self):
        try:
            f = float(self.freq_entry.get())
            if f < 20.0:  f = 20.0
            if f > 20000.0: f = 20000.0
            self.freq_var.set(f)
            self.tone.set_params(freq=f)
        except ValueError:
            messagebox.showwarning("Valor inválido", "Ingresá una frecuencia numérica (20–20000 Hz).")

    def _browse_wav(self):
        path = filedialog.askopenfilename(
            title="Elegí un archivo de audio",
            filetypes=[("Audio", "*.wav *.flac *.ogg *.oga"), ("Todos", "*.*")]
        )
        if path:
            self.wav_path_var.set(path)

    def _play_wav(self):
        path = self.wav_path_var.get().strip()
        if not path:
            messagebox.showinfo("Sin archivo", "Elegí un archivo primero.")
            return
        self.tone.set_params(enabled=False)
        self.player.play_file(path)

    def on_close(self):
        try:
            self.player.stop()
            self.tone.set_params(enabled=False)
            time.sleep(0.05)
            if hasattr(self, 'stream') and self.stream:
                self.stream.stop()
                self.stream.close()
        except Exception:
            pass
        self.destroy()

if __name__ == "__main__":
    app = App()
    app.mainloop()
PY
